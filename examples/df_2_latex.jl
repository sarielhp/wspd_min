#! /bin/env julial

# This script converts a dataframe file (e.g., CSV) into a LaTeX table source file.
#

using CSV
using DataFrames

"""
    escape_latex(s::AbstractString)

Escapes special LaTeX characters within a given string.
"""
function escape_latex(s::AbstractString)
    s = replace(s, "&" => "\\&")
    s = replace(s, "%" => "\\%")
    s = replace(s, "\$" => "\\\$")
    s = replace(s, "#" => "\\#")
    s = replace(s, "_" => "\\_")
    s = replace(s, "{" => "\\{")
    s = replace(s, "}" => "\\}")
    s = replace(s, "\\_" => " ")
    s = replace(s, "~" => "\\textasciitilde{}")
    s = replace(s, "^" => "\\textasciicaret{}")
    s = replace(s, "\\" => "\\textbackslash{}")
    s = replace(s, "IPLB" => "IP LB")
    return s
end

# Create methods for different types, especially for missing data
escape_latex(::Missing) = ""  # Represent missing values as empty strings
escape_latex(::Nothing) = ""  # Represent nothing as empty strings
escape_latex(v::Any) = escape_latex(string(v)) # Convert others to string first

function  escape_latex(v::Float64)
    if  isinteger( v )
        return  "\$" * escape_latex(string( round( Int, v ) ) ) * "\$"
    end
    return  escape_latex(string(v))
end  

"""
    dataframe_to_latex(df::DataFrame)

Converts a Julia DataFrame into a LaTeX `tabular` environment string.
Uses `booktabs` for professional-looking rules.
"""
function dataframe_to_latex(df::DataFrame)
    select!(df, Not(:IP), :IP)
    select!(df, Not(:IPLB), :IPLB)
    
    select!(df, Not(:IP_DJ), :IP_DJ)
    select!(df, Not(:IP_DJ_LB), :IP_DJ_LB)

    col_names = names(df)
    num_cols = length(col_names)
    
    # Use IOBuffer for efficient string building
    io = IOBuffer()

    # --- Start LaTeX Table ---
    # Add a comment
    println(io, "% Generated by df_to_latex.jl")
    println(io, "% Requires \\usepackage{booktabs} in your LaTeX preamble for \\toprule, \\midrule, \\bottomrule")
    
    # Define column alignment - default to 'l' (left) for all
    # You could make this more advanced (e.g., detect numeric types and use 'r')
    col_spec = "{ " * join(fill("l", num_cols), " ") * " }"
    println(io, "\\begin{tabular}{", col_spec, "}")
    println(io, "\\toprule")

    # --- Header Row ---
    escaped_headers = [escape_latex(name) for name in col_names]
    println(io, join(escaped_headers, " & "), " \\\\")
    println(io, "\\midrule")

    
    # --- Data Rows ---
    for row in eachrow(df)
        escaped_values = String[] # Initialize as String array
        println( typeof( row[ "IP_DJ_LB" ] ) )
        f_erase_DJ = ( row[ "IP_DJ_LB" ] == -1.0 )
        for col_name in col_names           
            #            println( col_name )
            val = row[col_name] # Get value by column name
            if  val == 0.0
                push!(escaped_values, "--" )
                continue 
            end
            local escaped_val::String
            if ismissing(val) || isnothing(val)
                escaped_val = "" # Use the same logic as escape_latex(::Missing)
            elseif ( col_name == "IP_DJ_LB" || col_name == "IP_DJ" ) && f_erase_DJ
                # Special case for IPLB column with value -1
                escaped_val = "--"
            else
                # Use the existing escape logic for all other cases
                escaped_val = escape_latex(val) # This will call escape_latex(string(val)) for numbers
            end
            push!(escaped_values, escaped_val)
        end
        println(io, join(escaped_values, " & "), " \\\\")
    end
   # --- End LaTeX Table ---
    println(io, "\\bottomrule")
    println(io, "\\end{tabular}")

    # Return the complete string
    return String(take!(io))
end

function dataframe_to_latex_old(df::DataFrame)
    col_names = names(df)
    num_cols = length(col_names)
    
    # Use IOBuffer for efficient string building
    io = IOBuffer()

    # --- Start LaTeX Table ---
    # Add a comment
    println(io, "% Generated by df_to_latex.jl")
    println(io, "% Requires \\usepackage{booktabs} in your LaTeX preamble for \\toprule, \\midrule, \\bottomrule")
    
    # Define column alignment - default to 'l' (left) for all
    # You could make this more advanced (e.g., detect numeric types and use 'r')
    col_spec = "{ " * join(fill("l", num_cols), " ") * " }"
    println(io, "\\begin{tabular}{", col_spec, "}")
    println(io, "\\toprule")

    # --- Header Row ---
    escaped_headers = [escape_latex(name) for name in col_names]
    println(io, join(escaped_headers, " & "), " \\\\")
    println(io, "\\midrule")

    # --- Data Rows ---
    for row in eachrow(df)
        # `values(row)` gets all values from the Row object
        escaped_values = [escape_latex(val) for val in values(row)]
        println(io, join(escaped_values, " & "), " \\\\")
    end

    # --- End LaTeX Table ---
    println(io, "\\bottomrule")
    println(io, "\\end{tabular}")

    # Return the complete string
    return String(take!(io))
end



function  (@main)(args)
    # 1. Check command line arguments
    if length(args) != 2
        println(stderr, "Error: Incorrect number of arguments.")
        println(stderr, "Usage: df_2_latex.jl <input_csv_file> <output_tex_file>")
        exit(1)
    end

    input_file = args[1]
    output_file = args[2]

    println("Starting conversion...")
    println("  Input file: $input_file")
    println("  Output file: $output_file")

    try
        # 2. Read the DataFrame
        if !isfile(input_file)
            println(stderr, "Error: Input file not found at $input_file")
            exit(1)
        end
        # The CSV.File(...) |> DataFrame pipeline is robust
        df = CSV.File(input_file) |> DataFrame

        select!(df, Not(:eps))
        
        # 3. Convert DataFrame to LaTeX string
        latex_table = dataframe_to_latex(df)

        # 4. Write the string to the output file
        open(output_file, "w") do f
            write(f, latex_table)
        end

        println("Successfully converted table to LaTeX at $output_file")

    catch e
        println(stderr, "An error occurred during conversion:")
        # Show the full error stack trace
        showerror(stderr, e, catch_backtrace())
        println(stderr)
        exit(1)
    end

    return  0
end
